# 第五章 述句 練習

## 練習 5.1

null statement 是什麼？什麼時候你會用到一個 null statement？

解：

只含一個單獨的分號的述句就是 null statement，如果在程式的某個地方，語法上需要一條述句但是邏輯上不需要，此時就應該使用 null statement

```cpp
while (cin >> s && s != sought)
	;
```

## 練習 5.2

區塊是什麼？什麼時候你會用到一個區塊？

解：

用大括號（curly brackets）包起來的述句和宣告的序列就是區塊，如果在程式的某個地方，語法上需要一條述句，而邏輯上需要多條述句，此時應該使用區塊

```cpp
while (val <= 10) {
  sum += val;
  ++val;
}
```

## 練習 5.3

使用逗號運算子（comma operator）改寫來自 1.4.1 的 while 迴圈，讓它不再需要一個區塊。解釋這種改寫方式增進或減少程式碼的可讀性

```cpp
while (val <= 10) sum += val, ++val;
```
程式碼的可讀性反而降低了

## 練習 5.4

解釋下列每個範例，更正你所發現的任何問題

```cpp
（a）while(string::iterator iter != s.end()) { /* . . . */
}
（b）while(bool status = find(word)) { /* . . . */
}
if (!status) { /* . . . */
}
```

解：

- （a）這個迴圈試圖用迭代器遍歷 string，但是變數的定義應該放在迴圈的外面，而目前的迴圈每次都會重新定義一個變數，因此是錯誤
- （b）這個迴圈的 while 和 if 是兩個獨立的述句，if 述句中無法存取 status 變數，正確的作法是應該將 if 包含在 while 裡面

## 練習 5.5

使用一個 if else 述句寫出你自己版本的程式，來從數值成績產生字母成績

```cpp
#include <iostream>
#include <vector>
#include <string>
using std::vector; using std::string; using std::cout; using std::endl; using std::cin;

int main()
{
    vector<string> scores = { "F", "D", "C", "B", "A", "A++" };
    for (int g; cin >> g;)
    {
        string letter;
        if (g < 60)
        {
            letter = scores[0];
        }
        else
        {
            letter = scores[(g - 50) / 10];
            if (g != 100)
                letter += g % 10 > 7 ? "+" : g % 10 < 3 ? "-" : "";
        }
        cout << letter << endl;
    }

    return 0;
}
```

## 練習 5.6

改寫你的成績程式，使用條件運算子（conditional operator），來取代 if else 述句

```cpp
#include <iostream>
#include <vector>
#include <string>
using std::vector; using std::string; using std::cout; using std::endl; using std::cin;

int main()
{
    vector<string> scores = { "F", "D", "C", "B", "A", "A++" };

    int grade = 0;
    while (cin >> grade)
    {
        string lettergrade = grade < 60 ? scores[0] : scores[(grade - 50) / 10];
        lettergrade += (grade == 100 || grade < 60) ? "" : (grade % 10 > 7) ? "+" : (grade % 10 < 3) ? "-" : "";
        cout << lettergrade << endl;
    }

    return 0;
}
```

## 練習 5.7

更正下列程式碼片段中的錯誤：

```cpp
(a) if (ival1 != ival2)
		ival1 = ival2
    else
    	ival1 = ival2 = 0;
(b) if (ival < minval)
		minval = ival;
    	occurs = 1;
(c) if (int ival = get_value())
    	cout << "ival = " << ival << endl;
    if (!ival)
    	cout << "ival = 0\n";
(d) if (ival = 0)
    	ival = get_value();
```

解：

- (a) `ival1 = ival2` 后面少了分号。
- (b) 应该用花括号括起来。
- (c) `if (!ival)` 应该改为 `else`。
- (d) `if (ival = 0)` 应该改为 `if (ival == 0)`。

## 練習 5.8

什麼是懸置的 else（dangling else）？C++ 中的 else 子句如何解析？

解：

用來描述在嵌套的 if else 述句中，如果 if 比 else 多時如何處理的問題。C++ 使用的方法是 else 配對最接近的 if，若沒有配對到即為懸置 else

## 練習 5.9

使用一系列的 if 述句寫一個程式計數從 cin 讀辱的文字中母音的總數

解：

```cpp
#include <iostream>

using std::cout; using std::endl; using std::cin;

int main()
{
	unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
	char ch;
	while (cin >> ch)
	{
		if (ch == 'a') ++aCnt;
		else if (ch == 'e') ++eCnt;
		else if (ch == 'i') ++iCnt;
		else if (ch == 'o') ++oCnt;
		else if (ch == 'u') ++uCnt;
	}
	cout << "Number of vowel a: \t" << aCnt << '\n'
		<< "Number of vowel e: \t" << eCnt << '\n'
		<< "Number of vowel i: \t" << iCnt << '\n'
		<< "Number of vowel o: \t" << oCnt << '\n'
		<< "Number of vowel u: \t" << uCnt << endl;

	return 0;
}
```

## 練習 5.10

我們實作的母音計數程式有一個問題：它不會把大寫字母算為母音。寫個能夠將大小寫字母都適切地算為母音的程式，也就是說，你的程式應該將 'a' 及 'A' 都累計到 aCnt，依此類推

解：

```cpp
#include <iostream>
using std::cin; using std::cout; using std::endl;

int main()
{
	unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
	char ch;
	while (cin >> ch)
		switch (ch)
	{
		case 'a':
		case 'A':
			++aCnt;
			break;
		case 'e':
		case 'E':
			++eCnt;
			break;
		case 'i':
		case 'I':
			++iCnt;
			break;
		case 'o':
		case 'O':
			++oCnt;
			break;
		case 'u':
		case 'U':
			++uCnt;
			break;
	}

	cout << "Number of vowel a(A): \t" << aCnt << '\n'
		<< "Number of vowel e(E): \t" << eCnt << '\n'
		<< "Number of vowel i(I): \t" << iCnt << '\n'
		<< "Number of vowel o(O): \t" << oCnt << '\n'
		<< "Number of vowel u(U): \t" << uCnt << endl;

	return 0;
}
```

## 練習 5.11

修改我們的母音計數程式，讓它也計數讀到的空格、tab 以及 newlines

解：

```cpp
#include <iostream>

using std::cin; using std::cout; using std::endl;

int main()
{
	unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0, spaceCnt = 0, tabCnt = 0, newLineCnt = 0;
	char ch;
	while (cin >> std::noskipws >> ch)  //noskipws(no skip whitespce)
		switch (ch)
	{
		case 'a':
		case 'A':
			++aCnt;
			break;
		case 'e':
		case 'E':
			++eCnt;
			break;
		case 'i':
		case 'I':
			++iCnt;
			break;
		case 'o':
		case 'O':
			++oCnt;
			break;
		case 'u':
		case 'U':
			++uCnt;
			break;
		case ' ':
			++spaceCnt;
			break;
		case '\t':
			++tabCnt;
			break;
		case '\n':
			++newLineCnt;
			break;
	}

	cout << "Number of vowel a(A): \t" << aCnt << '\n'
		<< "Number of vowel e(E): \t" << eCnt << '\n'
		<< "Number of vowel i(I): \t" << iCnt << '\n'
		<< "Number of vowel o(O): \t" << oCnt << '\n'
		<< "Number of vowel u(U): \t" << uCnt << '\n'
		<< "Number of space: \t" << spaceCnt << '\n'
		<< "Number of tab char: \t" << tabCnt << '\n'
		<< "Number of new line: \t" << newLineCnt << endl;

	return 0;
}
```

其中，使用 `std::noskipws`可以保留默认跳过的空格。

## 練習 5.12

修改我們的母音計數程式，讓它計數下列雙字母序列出現的頻率：ff、fl 與 fi

解：

```cpp
#include <iostream>

using std::cin; using std::cout; using std::endl;

int main()
{
	unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0, spaceCnt = 0, tabCnt = 0, newLineCnt = 0, ffCnt = 0, flCnt = 0, fiCnt = 0;
	char ch, prech = '\0';
	while (cin >> std::noskipws >> ch)
	{
		switch (ch)
		{
		case 'a':
		case 'A':
			++aCnt;
			break;
		case 'e':
		case 'E':
			++eCnt;
			break;
		case 'i':
			if (prech == 'f') ++fiCnt;
		case 'I':
			++iCnt;
			break;
		case 'o':
		case 'O':
			++oCnt;
			break;
		case 'u':
		case 'U':
			++uCnt;
			break;
		case ' ':
			++spaceCnt;
			break;
		case '\t':
			++tabCnt;
			break;
		case '\n':
			++newLineCnt;
			break;
		case 'f':
			if (prech == 'f') ++ffCnt;
			break;
		case 'l':
			if (prech == 'f') ++flCnt;
			break;
		}
		prech = ch;
	}

	cout << "Number of vowel a(A): \t" << aCnt << '\n'
		<< "Number of vowel e(E): \t" << eCnt << '\n'
		<< "Number of vowel i(I): \t" << iCnt << '\n'
		<< "Number of vowel o(O): \t" << oCnt << '\n'
		<< "Number of vowel u(U): \t" << uCnt << '\n'
		<< "Number of space: \t" << spaceCnt << '\n'
		<< "Number of tab char: \t" << tabCnt << '\n'
		<< "Number of new line: \t" << newLineCnt << '\n'
		<< "Number of ff: \t" << ffCnt << '\n'
		<< "Number of fl: \t" << flCnt << '\n'
		<< "Number of fi: \t" << fiCnt << endl;

	return 0;
}

```

## 練習 5.13

列於後面用於練習 5.13 的程式碼中的每個程式都含有一個常見的程式設計錯誤。請找出並更正每個錯誤

```cpp
(a) unsigned aCnt = 0, eCnt = 0, iouCnt = 0;
    char ch = next_text();
    switch (ch) {
        case 'a': aCnt++;
        case 'e': eCnt++;
        default: iouCnt++;
    }
(b) unsigned index = some_value();
    switch (index) {
        case 1:
            int ix = get_value();
            ivec[ ix ] = index;
            break;
        default:
            ix = ivec.size()-1;
            ivec[ ix ] = index;
    }
(c) unsigned evenCnt = 0, oddCnt = 0;
    int digit = get_num() % 10;
    switch (digit) {
        case 1, 3, 5, 7, 9:
            oddcnt++;
            break;
        case 2, 4, 6, 8, 10:
            evencnt++;
            break;
    }
(d) unsigned ival=512, jval=1024, kval=4096;
    unsigned bufsize;
    unsigned swt = get_bufCnt();
    switch(swt) {
        case ival:
            bufsize = ival * sizeof(int);
            break;
        case jval:
            bufsize = jval * sizeof(int);
            break;
        case kval:
            bufsize = kval * sizeof(int);
            break;
    }
```

解：

(a) 少了`break`语句。应该为：
```cpp
unsigned aCnt = 0, eCnt = 0, iouCnt = 0;
    char ch = next_text();
    switch (ch) {
    	case 'a': aCnt++; break;
    	case 'e': eCnt++; break;
    	default: iouCnt++; break;
    }
```

(b) 在`default`分支当中，`ix`未定义。应该在外部定义`ix`。
```cpp
unsigned index = some_value();
    int ix;
    switch (index) {
        case 1:
            ix = get_value();
            ivec[ ix ] = index;
            break;
        default:
            ix = static_cast<int>(ivec.size())-1;
            ivec[ ix ] = index;
    }
```

(c) `case`后面应该用冒号而不是逗号。
```cpp
unsigned evenCnt = 0, oddCnt = 0;
    int digit = get_num() % 10;
    switch (digit) {
        case 1: case 3: case 5: case 7: case 9:
            oddcnt++;
            break;
        case 2: case 4: case 6: case 8: case 0:
            evencnt++;
            break;
    }
```

(d) `case`标签必须是整型常量表达式。
```cpp
const unsigned ival=512, jval=1024, kval=4096;
    unsigned bufsize;
    unsigned swt = get_bufCnt();
    switch(swt) {
        case ival:
            bufsize = ival * sizeof(int);
            break;
        case jval:
            bufsize = jval * sizeof(int);
            break;
        case kval:
            bufsize = kval * sizeof(int);
            break;
    }
```

## 練習 5.14

寫個程式從標準輸入讀取 string，尋找重複的字詞。這個程式應該在輸入中找尋一個字詞後緊接著自身的地方。紀錄重複最多的次數，以及重複的是哪個字。印出次數最多的重複，或印出一個訊息表示沒有任何字詞重複。舉例來說，如果輸入是：how now now now brown cow cow，那麼輸出就應該指出 now 這個字出現了三次

解：

```cpp
#include <iostream>
#include <string>

using std::cout; using std::cin; using std::endl; using std::string; using std::pair;

int main()
{
    pair<string, int> max_duplicated;
    int count = 0;
    for (string str, prestr; cin >> str; prestr = str)
    {
        if (str == prestr) ++count;
        else count = 0;
        if (count > max_duplicated.second) max_duplicated = { prestr, count };
    }

    if (max_duplicated.first.empty()) cout << "There's no duplicated string." << endl;
    else cout << "the word " << max_duplicated.first << " occurred " << max_duplicated.second + 1 << " times. " << endl;

    return 0;
}
```

## 練習 5.15

解釋下列每個迴圈。更正你所偵測到的任何問題

```cpp
(a) for (int ix = 0; ix != sz; ++ix) { /* ... */ }
    if (ix != sz)
    	// . . .
(b) int ix;
    for (ix != sz; ++ix) { /* ... */ }
(c) for (int ix = 0; ix != sz; ++ix, ++sz) { /*...*/ }
```

解：

应该改为下面这样：

```cpp
(a) int ix;
    for (ix = 0; ix != sz; ++ix)  { /* ... */ }
    if (ix != sz)
    // . . .
(b) int ix;
    for (; ix != sz; ++ix) { /* ... */ }
(c) for (int ix = 0; ix != sz; ++ix) { /*...*/ }
```

## 練習 5.16

while 迴圈特別適合用於某個條件成立時就要重複執行的工作，例如當我們需要不斷讀取值，值到檔案結尾為止的時候。for 迴圈一般被想成是一種逐步迴圈（step loop）：藉由一個所引逐步處理過某個群集（collection）中一整個範圍（range）的值。以這兩個迴圈各自的習慣寫出兩個程式使用它們，然後改以另一個迴圈構造改寫這兩個程式。如果你只能使用一種迴圈，你會選哪個？為什麼呢？

解：

```cpp
int i;
while ( cin >> i )
    // ...


for (int i = 0; cin >> i;)
    // ...


for (int i = 0; i != size; ++i)
    // ...


int i = 0;
while (i != size)
{
    // ...
    ++i;
}
```
如果只能用一种循环，我会更倾向使用`while`，因为`while`显得简洁，代码可读性强。

## 練習 5.17

給定由 int 組成的兩個 vector，寫一個程式來判斷其中一個 vector 是否為另一個的前綴（prefix）。對於長度不同的 vector，比較較小的 vector 的元素數。舉例來說，若給定分別含有 0、1、1 與' 2 以及 0、1、1、2、3、5、8 的兩個 vector，你的程式應該回傳 true

解：

```cpp
#include <iostream>
#include <vector>

using std::cout; using std::vector;

bool is_prefix(vector<int> const& lhs, vector<int> const& rhs)
{
    if(lhs.size() > rhs.size())
        return is_prefix(rhs, lhs);
    for(unsigned i = 0; i != lhs.size(); ++i)
        if(lhs[i] != rhs[i]) return false;
    return true;
}

int main()
{
    vector<int> l{ 0, 1, 1, 2 };
    vector<int> r{ 0, 1, 1, 2, 3, 5, 8 };
    cout << (is_prefix(r, l) ? "yes\n" : "no\n");

    return 0;
}
```

## 練習 5.18

解釋下列的迴圈。更正你所偵測到的任何問題

```cpp
(a) do { // 应该添加花括号
        int v1, v2;
        cout << "Please enter two numbers to sum:" ;
        if (cin >> v1 >> v2)
            cout << "Sum is: " << v1 + v2 << endl;
    }while (cin);
(b) int ival;
    do {
        // . . .
    } while (ival = get_response()); // 应该将ival 定义在循环外
(c) int ival = get_response();
    do {
        ival = get_response();
    } while (ival); // 应该将ival 定义在循环外
```

## 練習 5.19

寫一個程式，使用 do while 向使用者重複請求兩個 string，並回報哪個 string 比較短

解：

```cpp
#include <iostream>
#include <string>

using std::cout; using std::cin; using std::endl; using std::string;

int main()
{
    string rsp;
    do {
        cout << "Input two strings: ";
        string str1, str2;
        cin >> str1 >> str2;
        cout << (str1 <= str2 ? str1 : str2)
             << " is less than the other. " << "\n\n"
             << "More? Enter yes or no: ";
        cin >> rsp;
    } while (!rsp.empty() && tolower(rsp[0]) == 'y');
    return 0;
}
```

## 練習 5.20
编写一段程序，从标准输入中读取`string`对象的序列直到连续出现两个相同的单词或者所有的单词都读完为止。
使用`while`循环一次读取一个单词，当一个单词连续出现两次时使用`break`语句终止循环。
输出连续重复出现的单词，或者输出一个消息说明没有任何单词是连续重复出现的。

解：

```cpp
#include <iostream>
#include <string>
using std::cout; using std::cin; using std::endl; using std::string;

int main()
{
    string read, tmp;
    while (cin >> read)
        if (read == tmp) break; else tmp = read;

    if (cin.eof())  cout << "no word was repeated." << endl; //eof(end of file)判断输入是否结束,或者文件结束符,等同于 CTRL+Z
    else            cout << read << " occurs twice in succession." << endl;

    return 0;
}
```

## 練習 5.21
修改5.5.1节練習 题的程序，使其找到的重复单词必须以大写字母开头。

解：

```cpp
#include <iostream>
using std::cin; using std::cout; using std::endl;
#include <string>
using std::string;

int main()
{
    string curr, prev;
    bool no_twice = true;
    while (cin >> curr)
    {
        if (isupper(curr[0]) && prev == curr)
        {
            cout << curr << ": occurs twice in succession." << endl;
            no_twice = false;
            break;
        }
        prev = curr;
    }

    if (no_twice)
        cout << "no word was repeated." << endl;

    return 0;
}
```

## 練習 5.22
本节的最后一个例子跳回到`begin`，其实使用循环能更好的完成该任务，重写这段代码，注意不再使用`goto`语句。

```cpp
// 向后跳过一个带初始化的变量定义是合法的
begin:
    int sz = get_size();
    if (sz <= 0) {
        goto begin;
    }
```

解：

用 for 循环修改的话就是这样
```cpp
for (int sz = get_size(); sz <=0; sz = get_size())
    ;
```

## 練習 5.23
编写一段程序，从标准输入读取两个整数，输出第一个数除以第二个数的结果。

解：

```cpp
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

int main()
{
    int i, j;
    cin >> i >> j;
    cout << i / j << endl;

    return 0;
}
```

## 練習 5.24
修改你的程序，使得当第二个数是0时抛出异常。先不要设定`catch`子句，运行程序并真的为除数输入0，看看会发生什么？

解：

```cpp
#include <iostream>
#include <stdexcept>

int main(void)
{
    int i, j;
    std::cin >> i >> j;
    if (j == 0)
        throw std::runtime_error("divisor is 0");
    std::cout << i / j << std::endl;

    return 0;
}
```

## 練習 5.25
修改上一题的程序，使用`try`语句块去捕获异常。`catch`子句应该为用户输出一条提示信息，询问其是否输入新数并重新执行`try`语句块的内容。

解：

```cpp
#include <iostream>
#include <stdexcept>
using std::cin; using std::cout; using std::endl; using std::runtime_error;

int main(void)
{
    for (int i, j; cout << "Input two integers:\n", cin >> i >> j; )
    {
        try
        {
            if (j == 0)
                throw runtime_error("divisor is 0");
            cout << i / j << endl;
        }
        catch (runtime_error err)
        {
            cout << err.what() << "\nTry again? Enter y or n" << endl;
            char c;
            cin >> c;
            if (!cin || c == 'n')
                break;
        }
    }

    return 0;
}
```