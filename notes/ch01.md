# 第一章 快速入門

## 熟悉編譯器

**g++**：

- 編譯（Compile）：`g++ --std=c++11 ch01.cpp -o main`
- 執行（Execute）：`./prog1`
- 查看程式執行完後的狀態：`echo $?`
- 編譯多個文件:`g++ ch2.cpp Sales_item.cc -o main`

輸入 `g++ --help`，查看編譯器參數：

```
Usage: g++ [options] file...
Options:
  -pass-exit-codes         Exit with highest error code from a phase
  --help                   Display this information
  --target-help            Display target specific command line options
  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...]
                           Display specific types of command line options
  (Use '-v --help' to display command line options of sub-processes)
  --version                Display compiler version information
  -dumpspecs               Display all of the built in spec strings
  -dumpversion             Display the version of the compiler
  -dumpmachine             Display the compiler's target processor
  -print-search-dirs       Display the directories in the compiler's search path
  -print-libgcc-file-name  Display the name of the compiler's companion library
  -print-file-name=<lib>   Display the full path to library <lib>
  -print-prog-name=<prog>  Display the full path to compiler component <prog>
  -print-multiarch         Display the target's normalized GNU triplet, used as
                           a component in the library path
  -print-multi-directory   Display the root directory for versions of libgcc
  -print-multi-lib         Display the mapping between command line options and
                           multiple library search directories
  -print-multi-os-directory Display the relative path to OS libraries
  -print-sysroot           Display the target libraries directory
  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers
  -Wa,<options>            Pass comma-separated <options> on to the assembler
  -Wp,<options>            Pass comma-separated <options> on to the preprocessor
  -Wl,<options>            Pass comma-separated <options> on to the linker
  -Xassembler <arg>        Pass <arg> on to the assembler
  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor
  -Xlinker <arg>           Pass <arg> on to the linker
  -save-temps              Do not delete intermediate files
  -save-temps=<arg>        Do not delete intermediate files
  -no-canonical-prefixes   Do not canonicalize paths when building relative
                           prefixes to other gcc components
  -pipe                    Use pipes rather than intermediate files
  -time                    Time the execution of each subprocess
  -specs=<file>            Override built-in specs with the contents of <file>
  -std=<standard>          Assume that the input sources are for <standard>
  --sysroot=<directory>    Use <directory> as the root directory for headers
                           and libraries
  -B <directory>           Add <directory> to the compiler's search paths
  -v                       Display the programs invoked by the compiler
  -###                     Like -v but options quoted and commands not executed
  -E                       Preprocess only; do not compile, assemble or link
  -S                       Compile only; do not assemble or link
  -c                       Compile and assemble, but do not link
  -o <file>                Place the output into <file>
  -pie                     Create a position independent executable
  -shared                  Create a shared library
  -x <language>            Specify the language of the following input files
                           Permissible languages include: c c++ assembler none
                           'none' means revert to the default behavior of
                           guessing the language based on the file's extension

```

輸入 `g++ -v --help`可以看到更完整的指令。
其他常用的：
```
-h FILENAME, -soname FILENAME: Set internal name of shared library
-I PROGRAM, --dynamic-linker PROGRAM: Set PROGRAM as the dynamic linker to use
-l LIBNAME, --library LIBNAME: Search for library LIBNAME
-L DIRECTORY, --library-path DIRECTORY: Add DIRECTORY to library search path
```

**獲得程式執行完後的狀態**:

- Windows: ``echo %ERRORLEVEL%``
- Unix: ``echo $?``

## IO

- ```#include <iostream>```
- ```std::cout << "hello"```
- ```std::cin >> v1```

記住`>>`和`<<`的運算都是左結合的，也就是`<<`執行完後，會留下輸入流和輸出流本身。

**endl**：這是一個被稱作**操控符（manipulator）**的特殊值，效果是結束當前所在的行，並且將周邊設備的緩衝區（buffer）中的内容刷（flush）到設備中。

Unix 和 Mac 下鍵盤的輸入文件結束符號（end-of-file），代表一個文件的結尾：`Ctrl+D`，Windows：`Ctrl+Z`

**標頭檔（Header）**：類別的類型一般都儲存在標頭檔之中，對於標準函式庫的標頭檔要使用`<>`框起來，而非標準庫的頭文件則使用`""`。宣告要寫在`.h`文件，類別的定義和實作則寫在`.cpp`文件之中。

**標頭保護（Header Guard）**：
使用 ifndef、define 巨集（Macro）以避免多次包含同一頭文件造成無法編譯的情況。
```cpp
#ifndef SALESITEM_H
#define SALESITEM_H
// Definition of Sales_itemclass and related functions goes here
#endif
```

**成員函数（類別方法 Class Method）**：使用`.`呼叫。

**命名空間（Namespace）**：使用範圍運算子`::`呼叫。

## 註解（Comments）

- 單行註解： `//`
- 多行註解： `/**/`。編譯器將`/*`和`*/`之間的內容都作為註解內容忽略。
```cpp
#define SALESITEM_H
/*
 * 多行註解格式
 * 每一行加一個 *
 */
```

## While Loop

循環執行，直到條件式（condition）為 false。

## For Loop

For Loop 的循環

循環頭部由三個部分组成：

- 一個初始化語句（Init-Statement）
- 一個循環條件（Condition）
- 一個表達式（Expression）

## 使用文件重定向

``./main <infile >outfile``
- main 是執行檔名稱
- infile 作為資料輸入檔
- outfile 作為資料輸出檔