# 第四章 述句

## 基礎知識

- **運算元轉換（type conversion）**：小整數型別會被提升（Promoted）為較大的整數類型
- **重載運算子（operator overloading）**：當運算子作用在類別型別的物件時，用戶可以自行定義其含意。
- **左值和右值（lvalue and rvalue）**：
    - C 語言中的原意：左值**可以**在運算式（expression）的左邊，右值則不能。
    - `C++`：當一個物件被用作**右值**的時候，用的是物件的**值**（内容）。
    - 被用做**左值**时，用的是物件的**身份**（在記憶體中的位置）。
- **估算（evaluated）的順序**：`int i = f1() + f2()`
  - 先計算`f1() + f2()`,再計算`int i = f1() + f2()`。但是 f1 和 f2 的估算（evaluted）的順序**先後並不確定**
## 算數運算子（arithmetic operators）

- **溢位（overflow）**：當計算的結果超出該型別所能表示的範圍時就會發生溢位（overflow）。
- **bool 型別不應該參與計算**
  ```cpp
  bool b=true;
  bool b2=-b;   //仍然為 true
  //b 為 true，提升為對應 int = 1，-b = -1
  //b2 = -1≠0，所以 b2 仍為 true
  ```
- 取餘數運算（modulus）m%n，结果的正負符號與 m 相同

## 邏輯運算子（logical operators）

- **短路估算（short-circuit evaluated）**：邏輯 And（&&）運算子與邏輯 Or（||）運算子都是先求左邊的值再求右邊的值，且當左側的運算結果無法確定該表達式（expression）的結果時才會計算右側的值。**先左再右**
- 小技巧，宣告為參考類型可以避免對元素的拷貝，例如，string 特别大時可以如果使用參考就可以節省下大量的複製時間。
```cpp
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

## 指定運算子（assignment operator）

- 指定運算的**回傳结果為它左側的物件**，且是一個左值。型別當然也就是左側物件的型別。
- 如果指定運算的左右兩側的運算物件的類型不同，則右側的物件會被嘗試轉換（conversion）成左側物件的類型。
- 指定運算子屬於**右结合律**，這點和其它的二元運算子（binary operator）不一樣。 `ival = jval = 0;`等價於`ival = (jval = 0);`
- 指定運算的優先級相較其他的運算子優先度（precedence）較低，使用其運算作為條件判斷時應加上括號。
- **複合指定運算子（compound assignment operator）只求值一次**（如 a += 5），但如果使用一般的指定運算子（如 a = a+5）的做法，則會需要求值兩次次。（可能會對性能有一點影響，但通常較流行的編譯器會優化）
  任意复合运算符op等价于`a = a op b;`

## 遞增與遞減運算子（increment and decrement operators）
* 前綴（prefix）版本`j = ++i`，先遞增後指定
* 後綴（postfix）版本`j = i++`，先指定後遞增

**優先使用前置**版本，因為後綴版本會需要多一步回傳原本儲存的原始值。（除非當下情況有需要變化前的值）

### 同時使用解參考（dereference）與遞增運算子（increment operator）

`*iter++`等價於`*(iter++)`，遞增運算子的優先級比較高（precedence）

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 輸出當前值，指針向後移動 1
```

## 成員存取運算子（member access operator）

`ptr->mem`等價於`(*ptr).mem`

注意`.`運算子優先級大於`*`，所以要記得加上括號

## 條件運算子（conditional ternary operator，ternary operator 又稱為三元運算子）

- 條件運算子（`?:`）允許我們把簡單的`if-else`嵌入到單一個運算式（expression）之中，按照如下形式：`cond ? expr1 : expr2`

- 該運算子可以嵌套使用，且為**右结合律**，從右向左順序結合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等價於
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 在運算式（expression）之中使用時記得是否該記得加上括號，因為條件運算子的優先級（precedence）太低。

## 位元運算子（bitwise operators）

用於測試或設定個別位元等等的操作。

- 位元運算子（bytewise operators）是作用於**整数型別**的物件。
- 二進位左移（`<<` right shift）或者右移（`>>` left shift），而移出邊界外的位元會被捨棄掉。
- 所有的位元運算子種類：Not（`~`）、And（`&`）、Or（`|`）、Xor（`^`）

有符號值（signed）的負數可能移位後變號，所以強烈建議**位元運算子僅用於無符號值（unsigned）**。

```c++
unsigned long quiz1 = 0;    // 每一位學生代表是否有通過考試
1UL << 12;  // 代表第 12 個學生通過了考試
quiz1 |= (1UL << 12);   // 將第 12 個學生修改為有通過
quiz1 &= ~(1UL << 12);  // 將第 12 個學生修改為未通過
bool stu12 = quiz1 & (1UL << 12);   // 判斷第 12 個學生是否有通過
```

> 位元運算子（bitwise operator）使用的機會較少，但是運算子重載（operator overloading）後的拿來操作 cout、cin 大家都用過

位元運算子（bitwise operator）是左結合律，優先度（precedence）介於中間，使用時盡量加上括號。

## sizeof 運算子（sizeof operator）

- 返回一個運算式的結果或一個類別物件（可使用類別名稱）所占用的**位元組數（byte）**。
- 返回的型別是 `size_t`的常數表達式（constant expression）。
- `sizeof`並不會實際計算其運算物件的值。
- 使用以下兩種形式：
  1. `sizeof (type name)`，使用類別名稱
  2. `sizeof (expr)`，使用表達式（expression）

```c++
int ia[10];
// sizeof(ia) 返回整個陣列所佔用空間的大小
// sizeof(ia)/sizeof(*ia) 返回陣列中含有的元素個數
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr[sz];
```

## 逗號運算子（comma operator）

從左向右依次求值。

左側的求值结果會被丟棄，逗號運算子（comma operator）**回傳的结果是右側表達式的值**，且結果如果是左值就是左值，如果是右值就是右值。

## 型別轉換（type conversion）

### 隱含的轉換（implicit conversion）

> 設計為盡可能避免損失精度，而轉換為更精細的型別。

- 比 `int` 小的整數值會先被提升（promoted）為較大的整數型別。
- 在條件中，非 bool 會被轉換成 bool。
- 初始化中，初始值會被轉換成變數的型別，在指定中，右運算元會被轉為左運算元的型別。
- 在混合了不同型別運算元的算術（arithmetic expression）和關係運算式（relational expression）中，型別會被轉換為共通的型別。
- 在函式呼叫（function call）的過程中也會發生轉換。
#### 算術轉換（arithmetic conversions）

##### 整數提升（integral promotions）

* 常見的 bool、char、short、unsigned char、unsigned short 等能存在 int 之中就會被提升（promotion）成 int，否則提升為`unsigned int`
* `wchar_t,char16_t,char32_t`提升為整數型別中`int,long,long long ……`最小的，且能容纳原型別所有可能值的類型。

#### 其它的隱含轉換

### 具名的強制轉型（named cast）

- **static_cast**：任何定義良好的型別轉換，除了涉及低階 const 的那些，都可以使用 static_cast，如：`double slope = static_cast<double>(j);`。

- **dynamic_cast**：支持執行時期的型態識別（run-time type identification）。

- **const_cast**：只能改變運算物件的底層 const，一般可用於去除 const 的性質，如：`const char *pc; char *p = const_cast<char*>(pc)`。

- **reinterpret_cast**：會對其運算元的位元模式（bit pattern）進行低階的重新解讀。

#### 舊式的強制型別轉換

`type (expr)`：函式形式的強制轉型記號
`(type) expr`：C 語言式的強制轉型記號