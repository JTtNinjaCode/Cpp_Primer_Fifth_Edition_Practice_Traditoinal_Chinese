# 第七章 類別 筆記

## 定義抽象資料型別

- 類別背後最基礎的概念：資料抽象化（data abstraction）和封裝（encapsulation）
- 資料抽象化仰賴介面（interface）和實作（implementation）之間的區別

### 類別成員（Member）

- 必須在類別的內部宣告，無法在其他地方增加成員
- 成員可以是資料、函式、型別別名（type alias）

### 定義成員函式

- 成員函式的宣告必須在類別內部
- 成員函式的定義既可以在類別的內部也可以在外部
- 使用成員存取運算子（member access operator）存取成員函數
- 編譯器會先編譯成員的宣告，然後再處理成員函式的主體，因此撰寫時使用成員變數的成員函式可以寫在成員變數的宣告之前
- this：
  - 每個成員函式都有一個額外的、隱含的參數 this
  - this 總是指向當前的物件，因此 this 是個常數的指標
  - this 這個指標本身已擁有頂層 const，而在參考列表後面加上 const 後會使 this 參數也擁有底層 const，因此無法修改 this 所指向的物件的值
  - return *this; 並且回傳值為左值參考，可以讓成員函數在同一行連續調用

### 定義非成員的類別相關函式

- 和類別相關的非成員函式，定義和聲明應該在類別定義的外部
- 和類別相關的非成員函式應將宣告和類別定義放在同一個標頭中

### 建構器（constructor）

- 類別控制物件初始化的方式是定義一個或多個叫做建構器（constructor）的特殊成員函式
- 建構器是特殊的成員函式，必須與類別名稱同名、沒有回傳型別，且不可被宣告為 const
- 建構器放在類別的 public 部分

合成的預設建構器：
- 編譯器只會在一個類別沒有顯式宣告建構器的時候產生一個預設建構器，該建構器的參數列表不帶任何參數
- 合成建構器初始化類別的每個資料成員方法如下：
  - 如果類別中有初始器可用，就用它來初始化該成員
  - 否則，就預設初始化該成員
- 具有內建或複合型別成員的類別應該只在所有的這些成員都有類別內初始器的情況下仰賴合成的預設建構器
- 如果類別內的成員無法被預設初始化，那麼一定無法使用預設建構器
- Ctor() = default 會要求編譯器合成預設的建構器（C++11），當已經定義其他建構器，但又想保留預設的建構器時可以使用

建構器初始器串列（constructor initializer list）
- 冒號和大括號之間的程式碼：Sales_item(): units_sold(0), revenue(0.0) {} 即為建構器初始器列表，使用逗號分離
- 建構器不應該覆寫類別內初始器，除非你想要使用不同的初始值。如果你的編譯器較舊，無法使用類別內初始器，那麼每個建構器都應該使用初始器串列明確地初始化具有內建型別的每個成員

拷貝、指定與解構：
- 除了預設建構器，編譯器還會幫我們自動合成拷貝、指定和解構等等的運算函式，這將在第 13 章會深入探討

## 存取控制與封裝

存取指定符（access specifiers）：
- public：定義在 public 後面的成員在整個程式內都可以被直接存取，用於定義類別的介面
- private：定義在 private 後面的成員可以被類別的成員函數存取，但不能被使用該類別的程式碼存取，用於隱藏類別的實作
使用 class 或 struct 關鍵字
- 兩者在 C++ 中屬於同義字，都可以被用於定義一個類別，唯一的差別僅在於預設存取權限
- class：預設為 private 的，直到第一個存取指定符之前
- struct：預設為 public 的，直到第一個存取指定符之前

### Friends

- 允許特定的非成員函數或類別存取一個類別的所有成員，包含非 public 成員
- 一個類別讓一個非成員函式成為它的 friend 的方式是為那個函式引入前面接著關鍵字 friend 的宣告：friend Sales_data add(const Sales_data&, const Sales_data&);
- 通常會將 friend 宣告集中在類別定義的開頭或尾端
- 一個 friend 只會影響到存取控制，它並不是函式的一般性宣告，如果我們希望類別的使用者能夠呼叫一個 friend 函式，那麼我們也必須在 friend 宣告之外個別宣告那個函式
- 如果一個類別指定了 Friend 類別，則 Friend 類別的成員函式可以存取類別內的所有成員，包含非 public 的成員

### 封裝的好處

- 使用者程式碼因此不會不小心毀損一個經過封裝的物件之狀態
- 經過封裝的類別之實作可以隨時間演進，而不需要使用者層級的程式碼有所變更

## 額外的類別功能

讓成員變為 inline：
 - 類別內部經常會有能夠受益於 inline 的小型程式，適合被宣告成 inline 函式
 - 定義在類別內部的函式是自動 inline 的
 - 在類別外部定義的成員函式，也可以在宣告時顯式地加上 inline
mutable 資料成員：
 - mutable 永遠不會是頂層 const 的，即使是在 const 成員函式內也是如此
 - 若我們要提供一個類別內初始器，我們必須使用一個等號或大括號，而不能使用小括號

### 類別宣告
- 可以宣告一個類別但不定義它，前向宣告（forward declaration）
- 一個宣告之後，在看到定義之前都是一個不完整的型別（incomplete type）
- 只能以有限的方式使用一個不完整型別（incomplete type），我們可以定義指向這種型別的指標或參考，而我們可以宣告（但不能定義）使用不完整型別作為參數或回傳型別的函式
- 定義類別中的資料成員必須已經是完整的（completed），因為編譯器得知道這個資料成員需要多少的儲存空間，但不完整的型別是無法知道它所需要的空間的，因此無法作為資料成員
- 一個類別直到其類別主體完結前都尚未定義，因此也無法以自己為資料成員的型別

## 類別範疇

- 每個類別都定義自己的新範疇，在類別的範疇之外，普通的資料和函式成員只能由參考、物件或指標使用成員存取運算子來存取
- 函式的回傳型別通常在函式前面，因此當成員函式定義在類別的外部時，回傳型別中使用的名稱都位於類別的範疇之外
- 類別定義會以兩個階段處理：
  1. 成員宣告會先被編譯
  2. 在看過整個類別後，函式主體才會被編譯
- 類別中的型別別名都要放在最一開始

成員定義內的一般區塊範疇名稱查找：
1. 先從成員函式內尋找該名稱的宣告，如同以往，函式主體中，只有出現在該名稱使用處之前的宣告會被考慮
2. 如果成員函式內找不到宣告，就在類別內尋找宣告，類別內的所有成員都會納入考慮
3. 如果類別中找不到那個名稱的宣告，就在成員函式定義之前找尋在範疇中的宣告
- 不良實務做法：成員函式的區域名稱不應該遮蔽成員名稱

## 再訪建構器

- 建構器初始器串列：
  - 注意初始化與指定的差別：寫在建構器初始器串列的用法是初始化，但寫在函式主體中是使用指定，且已先被預設初始化，對於某些不支援預設初始化的類別會出錯
  - 最好讓建構器初始器串列初始化的順序和成員變數宣告的順序一致，且不要使用資料成員初始化另一個資料成員
  - 如果資料成員是 const、參考，或者沒有提供預設建構器的類別型別，我們就必須使用建構器初始器串列來為它們提供值

### 委派建構器（delegating constructor，C++11）

- 委託建構器可以將自己的職責委託給其他的建構器
- Sale_data(): Sale_data("", 0, 0) {}

### 預設建構器的角色

預設建構器會在一個物件是預設初始化或者值初始化（value initialized）的時候自動被使用

預設初始化發生的時機：
- 當在區塊範疇定義非 static 變數或陣列而不帶初始器的時候
- 一個類別本身所具有的成員之型別會使用合成的預設建構器的時候
- 當類別型別的成員沒有在建構器初始器串列中被明確初始化的時候

值初始化發生的時機：
- 陣列初始化的過程中，當我們提供的初始器數目少於陣列大小之時
- 不帶初始器定義一個區域性 static 物件的時候
- 當我們寫出 T() 的運算式，而其中 T 是一個型別名稱的時候（接受單一一個引數來指定其 vector 大小的 vector 建構器就用了一個這種的引數來值初始化其元素初始器）

### 隱含的類別型別轉換

- 如果建構器只接受一個引數，則它實際上定義了轉換了此類別型別的隱含轉換的機制，這種建構器又叫做轉換建構器（converting constructors）
- 編譯器只會自動地執行一步隱含的型別轉換，多步轉換是禁止的
- 抑制建構器所定義的隱含轉換：
  - 將建構器宣告為 exlicit
  - 使用 explicit 建構器修飾後則該建構器只能用於直接初始化
  - 可以使用 static_cast 以強制使用 exlicit 建構器

### 彙總類別（aggregate class）

一個彙總類別（aggregate class）賦予使用者對其成員的直接存取，並具有特殊的初始化語法，只要符合以下條件，就是一個彙總類別
- 它所有的資料成員都是 public 的（成員函式可以是 private 的）
- 它沒有定義任何建構器
- 它沒有類別內初始器
- 它沒有基礎類別（base class）或 virtual 函式，這將在第 15 章中涵蓋

彙總類別有以下特性：
- 可使用一個大括號圍起的成員初始器串列來初始化一個彙總類別的資料型別
- 如同陣列的初始化，如果初始器串列的元素值比類別所具有的成員數還少，那麼尾端的成員會是值初始化的

### 字面值類別

- 字面值型別：除了算術型別、參考和指標，某些類別也是字面值型別
- 資料成員都必須是字面值型別的彙總類別是字面值類別
- 如果彙總類別，則必須滿足以下條件才屬於字面值類別：
  - 資料成員都必須是字面值型別
  - 類別必須至少有一個 constexpr 建構器
  - 如果一個資料成員含有類別內部初始值，則內建型別成員的初始值必須是一條常數表達式，或者如果成員屬於某種類別型別，則初始值必須使用成員自己的 constexpr 建構器
  - 類別必須使用解構器的默認定義，該成員函式負責銷毀類別的物件

## static 類別成員

- 非 static 的資料成員存在於類別型別的每個物件中
- static 資料成員獨立於該類別的任意個別物件而存在
- 宣告：
  - 宣告之前加上關鍵字 static
- 使用：
  - 使用範疇運算子::直接存取 static 成員，如：r = Account::rate();
  - 也可以使用個別物件存取：r = ac.rate();
  - 在成員函式內可以直接使用，不需要使用範疇運算子
- 定義：
  - 可在類別定義內或類別定義外定義成員函式
  - 在類別外部定義靜態成員函式時不需要加上 static
  - 無法在類別內初始化一個 static 資料成員，必須在類別主體外定義並初始化每個 static 資料成員
  - 就像全域物件，static 資料成員是定義在任何函式之外，因此一旦它們被定義，就會持續存在直到程式執行完畢為止
  - 可以為具有 const 整數型別的 static 成員提供類別內初始器，而且必須為字面值型別的 constexpr 的 static 成員